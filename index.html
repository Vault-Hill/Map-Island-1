<!DOCTYPE html>
<html lang="en">
  <head>
    <title>VAULT HILL</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

    <style>
      body {
        background-color: #122230;
        padding: 0;
        margin: 0;
        min-height: 100vh;
      }

      #scene {
        width: 100vw;
        height: 100vh;
      }

      #tooltip {
        position: absolute;
        top: 0px;
        left: -350px;
        background-color: #fff;
        padding: 15px;
        border-radius: 5px;
      }
    </style>
  </head>

  <body>
    <div id="scene"></div>
    <div id="tooltip"></div>
    <script src="./d3.v7.min.js"></script>
    <script type="module">
      // WATER 122230
      // GREEN 041922
      // GROUND 0a0f1d
      // STREETS AND BRIDGES 32495c
      // EXLUSIVE c1e5e6
      // DELUXE 75bac1
      // PREMIUM 4aa6af
      // STANDARD 00929c

      const colors = {
        Water: 0x122230,
        Green: 0x041922,
        Ground: 0x0a0f1d,
        Streets: 0x32495c,
        Exclusive: 0xc1e5e6,
        Deluxe: 0x75bac1,
        Premium: 0x4aa6af,
        Standard: 0x00929c,
      };

      const sizes = {
        Exclusive: 48,
        Deluxe: 32,
        Premium: 16,
        Standard: 8,
      };

      import * as THREE from "./three.module.js";

      import { OrbitControls } from "./OrbitControls.js";

      let camera, controls, scene, renderer, raycaster, INTERSECTED, lands;
      const pointer = new THREE.Vector2();
      const tooltip = {};

      Promise.all([
        d3.csv("./data.csv", d3.autoType),
        d3.dsv(";", "./VHC_MAPandGreens.csv"),
        d3.dsv(";", "./VHC_MAPandstreets.csv"),
      ]).then(([data, greens, streets]) => {
        const greenData = processGreens(greens);
        const streetsData = processStreets(streets);
        init(data, greenData, streetsData);
        animate();
      });

      function init(data, greenData, streetsData) {
        const [minZ, maxZ] = d3.extent(data, (d) => d.y1);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(colors.Water);
        // scene.fog = new THREE.FogExp2(0x0f1d29, 0.002);

        raycaster = new THREE.Raycaster();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("scene").appendChild(renderer.domElement);
        document.addEventListener("mousemove", onPointerMove);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.01,
          100000
        );

        camera.position.set(0, maxZ * 2, 0);

        // controls

        controls = new OrbitControls(camera, renderer.domElement);
        controls.listenToKeyEvents(window); // optional

        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

        controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        controls.dampingFactor = 0.05;

        controls.screenSpacePanning = false;

        controls.minDistance = 100;
        controls.maxDistance = maxZ * 5;

        controls.maxPolarAngle = Math.PI / 2.5;

        // world

        const greeSpace = new THREE.Group();

        greenData.forEach((d) => {
          const land = createPolygon(d.orig_coords);
          land.rotateX(Math.PI / 2);
          greeSpace.add(land);
        });

        scene.add(greeSpace);

        const streets = new THREE.Group();

        streetsData.forEach((d) => {
          const m = createPolygon(d.orig_coords, {color: colors.Streets});
          m.rotateX(Math.PI / 2);
          streets.add(m);
        });

        scene.add(streets);

        // const geometry = new THREE.BoxGeometry(32, 1, 32);

        const geometries = {
          Exclusive: new THREE.BoxGeometry(32, sizes.Exclusive, 32),
          Deluxe: new THREE.BoxGeometry(32, sizes.Deluxe, 32),
          Premium: new THREE.BoxGeometry(32, sizes.Premium, 32),
          Standard: new THREE.BoxGeometry(32, sizes.Standard, 32),
        }


        lands = new THREE.Group();

        for (let i = 0; i < data.length; i++) {
          const { x1, y1, ...rest } = data[i];
          const type = rest.Name.split("_")[0];
          const geometry = geometries[type];
          const mat = new THREE.MeshStandardMaterial({
            color: colors[type],
            flatShading: true,
            side: THREE.DoubleSide,
          });

          const mesh = new THREE.Mesh(geometry, mat);

          mesh.userData = rest;
          mesh.position.x = x1;
          mesh.position.y = 0;
          mesh.position.z = y1;

          mesh.updateMatrix();
          mesh.matrixAutoUpdate = false;

          lands.add(mesh);
        }

        scene.add(lands);

        // lights

        const dirLight1 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight1.position.set(-10, -10, -10);
        scene.add(dirLight1);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 1);
        dirLight2.position.set(10, 10, 10);
        scene.add(dirLight2);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        window.addEventListener("resize", onWindowResize);
      }

      function createPolygon(poly, opts) {
        var shape = new THREE.Shape();

        shape.moveTo(poly[0][0], poly[0][1]);

        for (var i = 1; i < poly.length; ++i) {
          shape.lineTo(poly[i][0], poly[i][1]);
        }

        shape.lineTo(poly[0][0], poly[0][1]);

        var geometry = new THREE.ShapeGeometry(shape);
        var material = new THREE.MeshBasicMaterial({
          color: colors.Green,
          side: THREE.DoubleSide,
          depthWrite: false,
          side: THREE.DoubleSide,
          polygonOffset: true,
          polygonOffsetFactor: -4,
          polygonOffsetUnits: 1,
          ...(opts || {})
        });
        const m = new THREE.Mesh(geometry, material);
        m.renderDepth = 0;
        return m;
      }

      function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        tooltip.x = event.clientX;
        tooltip.y = event.clientY;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        render();
      }

      function render() {
        raycaster.setFromCamera(pointer, camera);

        const intersects = raycaster.intersectObjects(lands.children, false);

        if (intersects.length > 0) {
          if (INTERSECTED != intersects[0].object) {
            if (INTERSECTED)
              INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

            INTERSECTED = intersects[0].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex(0xff0000);
            showTooltip();
          }
        } else {
          if (INTERSECTED)
            INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
          INTERSECTED = null;
          hideTooltip();
        }

        renderer.render(scene, camera);
      }

      function showTooltip() {
        if (!INTERSECTED) return hideTooltip();

        const t = document.getElementById("tooltip");
        const datum = INTERSECTED.userData;

        t.style.left = tooltip.x + 5 + "px";
        t.style.top = tooltip.y + 5 + "px";

        t.innerHTML = `
          <div style="margin-bottom: 10px">ID: ${datum.ID}</div>
          <div>NAME: ${datum.Name}</div>
        `;
      }

      function hideTooltip() {
        const t = document.getElementById("tooltip");

        t.style.left = "-350px";
        t.innerHTML = "";
      }

      function processStreets(input) {
        const grouped = d3.group(input, (d) => d.Name);

        const columns = input.columns.slice(2);

        return input.map((d) => {
          const coords = columns
            .filter((x) => d[x])
            .map((x) => {
              return d[x].split(",").map((x) => +x);
            });

          return {
            Name: d.Name,
            // coords: all_coords,
            orig_coords: coords,
          };
        });
      }

      function processGreens(greens) {
        const grouped = d3.group(greens, (d) => d.Name);

        const columns = greens.columns.slice(2);

        return greens.map((d) => {
          const coords = columns
            .filter((x) => d[x])
            .map((x) => {
              return d[x].split(",").map((x) => +x);
            });

          return {
            Name: d.Name,
            // coords: all_coords,
            orig_coords: coords,
          };
        });
      }
    </script>
  </body>
</html>
